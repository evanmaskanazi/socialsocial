<!DOCTYPE html>
<!-- TheraSocial Circles Version PJ702 -->
<!-- PJ501 Changes: Added block check before displaying user profile -->
<!-- PJ601 Changes: Block/Unblock toggle button fix, Fixed navigation after 403 errors -->
<!-- PJ602 Changes: Fixed Follow button width -->
<!-- PJ701 Changes: Hide Add to Circle button if user is already in any of my circles -->
<!-- PJ702 Changes: Improved circle membership check with better logging and robust ID comparison -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circles - TheraSocial</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        /* RTL Support */
        [dir="rtl"] {
            direction: rtl;
        }

        [dir="rtl"] .circles-container {
            text-align: right;
        }

        [dir="rtl"] .circle-selector {
            flex-direction: row-reverse;
        }
    </style>
</head>
<body>
    <div id="loadingMessage" style="text-align: center; padding: 20px; font-size: 18px; color: white;">Loading circles...</div>
    <div id="circlesContainer" style="opacity: 0; transition: opacity 0.2s;"></div>

    <script src="/static/js/i18n.js"></script>
    <script src="/static/js/circles-messages.js?v=702.0"></script>
    <script src="/static/js/feed-updates.js?v=202.0"></script>

    <script>
        // SINGLE initialization flag to prevent race conditions
        let pageInitialized = false;
        let isUpdatingLanguage = false; // Prevent concurrent language updates

        // Verify authentication before loading
        async function checkAuthentication() {
            try {
                const response = await fetch('/api/auth/session');
                if (response.status === 401) {
                    window.location.href = '/';
                    return false;
                }
                return true;
            } catch (error) {
                console.error('Error checking authentication:', error);
                return false;
            }
        }

        // Monitor DOM for when circles are actually populated
        function waitForCirclesPopulated(maxWaitMs = 3000) {
            return new Promise((resolve) => {
                const startTime = Date.now();

                const checkPopulated = () => {
                    const publicMembers = document.getElementById('publicMembers');
                    const classBMembers = document.getElementById('class_bMembers');
                    const classAMembers = document.getElementById('class_aMembers');

                    const hasRealContent =
                        (publicMembers && (
                            publicMembers.querySelector('.member-item') ||
                            publicMembers.textContent.includes('private')
                        )) ||
                        (classBMembers && (
                            classBMembers.querySelector('.member-item') ||
                            classBMembers.textContent.includes('private')
                        )) ||
                        (classAMembers && (
                            classAMembers.querySelector('.member-item') ||
                            classAMembers.textContent.includes('private')
                        ));

                    if (hasRealContent) {
                        console.log('Circles populated with real data');
                        resolve(true);
                        return;
                    }

                    if (Date.now() - startTime > maxWaitMs) {
                        console.warn('Timeout waiting for circles to populate');
                        resolve(false);
                        return;
                    }

                    setTimeout(checkPopulated, 50);
                };

                checkPopulated();
            });
        }

        // MAIN INITIALIZATION - runs exactly once
        async function initializeCirclesPage() {
            if (pageInitialized) {
                console.log('Page already initialized, skipping...');
                return;
            }
            pageInitialized = true;

            console.log('Circles page initializing...');

            // 1. Check authentication first
            const isAuthenticated = await checkAuthentication();
            if (!isAuthenticated) return;

            // 2. Wait for i18n to load
            let waitCount = 0;
            while ((!window.i18n || !window.i18n.translations) && waitCount < 20) {
                await new Promise(resolve => setTimeout(resolve, 100));
                waitCount++;
            }

            // 3. Add circle translations if available
            if (typeof addCircleTranslations === 'function') {
                addCircleTranslations();
            }

            // 4. Load HTML structure (invisible)
            if (typeof circlesHTML !== 'undefined') {
                document.getElementById('circlesContainer').innerHTML = circlesHTML;
                console.log('Circles HTML loaded');
            } else {
                console.error('circlesHTML not found');
                return;
            }

         // 5. Apply user's language preference from localStorage
// Note: We only read from localStorage to avoid race conditions with the main dashboard
// The main dashboard handles syncing language with the backend
try {
    const localLang = localStorage.getItem('selectedLanguage');
    console.log('[Circles] Using localStorage language (no backend sync):', localLang);

    const langToUse = localLang || 'en';

    if (window.i18n && window.i18n.setLanguage) {
        await window.i18n.setLanguage(langToUse);
        console.log('[Circles] Language set to:', langToUse);
    }
} catch (error) {
    console.log('[Circles] Error setting language:', error);
}

            // 6. Apply initial translations
            if (window.i18n && window.i18n.applyLanguage) {
                const currentLang = window.i18n.getCurrentLanguage ? window.i18n.getCurrentLanguage() : 'en';
                window.i18n.applyLanguage(currentLang);

                // Set RTL direction
                const rtlLanguages = ['ar', 'he'];
                document.body.setAttribute('dir', rtlLanguages.includes(currentLang) ? 'rtl' : 'ltr');
            }

            // 7. Initialize circles data
            if (typeof initializeCircles === 'function') {
                console.log('Calling initializeCircles');
                initializeCircles();
            } else if (typeof loadCircles === 'function') {
                console.log('Calling loadCircles');
                loadCircles();
            } else {
                console.error('No circle initialization function found');
                return;
            }

            // 8. Wait for circles to populate
            console.log('Waiting for circles to populate...');
            await waitForCirclesPopulated(3000);

            // 9. Apply translations (after data loaded)
            if (window.i18n && window.i18n.applyLanguage) {
                const currentLang = window.i18n.getCurrentLanguage ? window.i18n.getCurrentLanguage() : 'en';
                window.i18n.applyLanguage(currentLang);
            }

            // 10. Update circle displays (member lists)
            if (typeof updateCirclesDisplay === 'function') {
                updateCirclesDisplay();
            }

            // 11. Update privacy dropdown translations
            if (typeof updatePrivacyDropdownTranslations === 'function') {
                updatePrivacyDropdownTranslations();
            }

            // 12. Force-update circle titles as FINAL step (with delay to ensure all other translations complete)
            // This fixes the race condition where applyLanguage() was overwriting manual title updates
            if (typeof updateCircleTitles === 'function') {
                setTimeout(() => {
                    updateCircleTitles();
                    console.log('[Circles] Final circle titles update complete');
                }, 100);
            }

            // 12.5. Load circle recommendations (explicit call as backup)
            if (typeof loadCircleRecommendations === 'function') {
                setTimeout(() => {
                    console.log('[Circles] Explicitly calling loadCircleRecommendations');
                    loadCircleRecommendations();
                }, 200);
            }

            // PJN452: Add action buttons when viewing another user's circles
            const urlParams = new URLSearchParams(window.location.search);
            const viewingUserId = urlParams.get('user_id');
            if (viewingUserId) {
                console.log('[Circles] Viewing another user circles, adding action buttons');
                await addCirclesActionButtons(parseInt(viewingUserId));
            }

            // 13. Make visible
            const container = document.getElementById('circlesContainer');
            const loadingDiv = document.getElementById('loadingMessage');
            container.style.opacity = '1';
            if (loadingDiv) loadingDiv.style.display = 'none';

            console.log('Circles page fully initialized and visible');
        }

        // PJN452: Add action buttons to circles page when viewing another user
        // PJ501: Added block check before displaying user profile
        async function addCirclesActionButtons(userId) {
            try {
                // PJ501: Check if blocked by this user first
                try {
                    const blockCheckResponse = await fetch(`/api/users/${userId}/check-blocked`, { credentials: 'include' });
                    if (blockCheckResponse.ok) {
                        const blockStatus = await blockCheckResponse.json();
                        if (blockStatus.blockedBy || blockStatus.is_blocked) {
                            // Show Account Not Available message and redirect
                            const lang = localStorage.getItem('selectedLanguage') || 'en';
                            const messages = {
                                'en': 'Account Not Available',
                                'he': 'חשבון לא זמין',
                                'ar': 'الحساب غير متاح',
                                'ru': 'Аккаунт недоступен'
                            };
                            alert(messages[lang] || messages['en']);
                            window.location.href = '/?view=following';
                            return;
                        }
                    }
                } catch (e) {
                    console.error('Error checking block status:', e);
                }
                
                // Get user profile info
                const profileResponse = await fetch(`/api/users/${userId}/profile`, { credentials: 'include' });
                if (!profileResponse.ok) {
                    // PJ501: Check if blocked (403 with blocked error)
                    if (profileResponse.status === 403) {
                        const errorData = await profileResponse.json().catch(() => ({}));
                        if (errorData.blocked || errorData.error === 'account_not_available') {
                            const lang = localStorage.getItem('selectedLanguage') || 'en';
                            const messages = {
                                'en': 'Account Not Available',
                                'he': 'חשבון לא זמין',
                                'ar': 'الحساب غير متاح',
                                'ru': 'Аккаунт недоступен'
                            };
                            alert(messages[lang] || messages['en']);
                            window.location.href = '/?view=following';
                            return;
                        }
                    }
                    return;
                }
                const userData = await profileResponse.json();
                const username = userData.username || 'User';
                
                // Check if following
                let isFollowing = false;
                try {
                    const followingResponse = await fetch('/api/following', { credentials: 'include' });
                    if (followingResponse.ok) {
                        const followingData = await followingResponse.json();
                        isFollowing = followingData.following.some(u => u.id === userId);
                    }
                } catch (e) {
                    console.error('Error checking following status:', e);
                }
                
                // Translation labels
                const lang = localStorage.getItem('selectedLanguage') || 'en';
                const labels = {
                    'en': { back: '← Back to Following', follow: 'Follow', unfollow: 'Unfollow', addToCircle: 'Add to Circle', block: 'Block', unblock: 'Unblock' },
                    'he': { back: '← חזרה לעוקבים', follow: 'עקוב', unfollow: 'הפסק לעקוב', addToCircle: 'הוסף למעגל', block: 'חסום', unblock: 'בטל חסימה' },
                    'ar': { back: '← العودة للمتابعين', follow: 'متابعة', unfollow: 'إلغاء المتابعة', addToCircle: 'إضافة إلى دائرة', block: 'حظر', unblock: 'إلغاء الحظر' },
                    'ru': { back: '← Назад к подписчикам', follow: 'Подписаться', unfollow: 'Отписаться', addToCircle: 'Добавить в круг', block: 'Заблокировать', unblock: 'Разблокировать' }
                };
                const t = labels[lang] || labels['en'];
                
                // PJ601: Check if user is blocked
                let isBlocked = false;
                try {
                    const blockedResponse = await fetch('/api/blocked-users', { credentials: 'include' });
                    if (blockedResponse.ok) {
                        const blockedData = await blockedResponse.json();
                        if (blockedData.blocked_users) {
                            isBlocked = blockedData.blocked_users.some(u => u.id === userId);
                        }
                    }
                } catch (e) {
                    console.error('Error checking blocked status:', e);
                }
                
                // PJ702: Check if user is already in any of my circles (improved)
                let isInCircles = false;
                try {
                    // Fetch MY circles (without user_id param) to check if viewed user is in them
                    const circlesResponse = await fetch('/api/circles', { credentials: 'include' });
                    if (circlesResponse.ok) {
                        const circlesData = await circlesResponse.json();
                        console.log('[PJ702] My circles data:', circlesData);
                        console.log('[PJ702] Checking if userId', userId, 'is in my circles');
                        
                        // Check all circle types: general/public, close_friends/class_b, family/class_a
                        const publicCircle = circlesData.general || circlesData.public || [];
                        const classBCircle = circlesData.close_friends || circlesData.class_b || [];
                        const classACircle = circlesData.family || circlesData.class_a || [];
                        
                        const allCircleMembers = [...publicCircle, ...classBCircle, ...classACircle];
                        console.log('[PJ702] All circle members:', allCircleMembers.map(m => ({id: m.id, username: m.username})));
                        
                        // Use Number() for robust comparison in case of type mismatch
                        isInCircles = allCircleMembers.some(m => Number(m.id) === Number(userId));
                        console.log('[PJ702] isInCircles result:', isInCircles);
                    }
                } catch (e) {
                    console.error('Error checking circles:', e);
                }
                
                // Create container for buttons
                const container = document.getElementById('circlesContainer');
                if (!container) return;
                
                // Create back button
                const backBtn = document.createElement('button');
                backBtn.className = 'btn-secondary back-to-following-btn';
                backBtn.textContent = t.back;
                backBtn.style.cssText = 'margin-bottom: 1rem; display: block;';
                backBtn.onclick = () => {
                    window.location.href = '/?view=following';
                };
                
                // Create action buttons container
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'profile-action-buttons';
                buttonContainer.style.cssText = 'display: flex; flex-wrap: wrap; gap: 0.5rem; margin: 1rem 0; padding: 0.5rem; background: #f8f9fa; border-radius: 8px;';
                
                if (isFollowing) {
                    const unfollowBtn = document.createElement('button');
                    unfollowBtn.className = 'btn-secondary';
                    unfollowBtn.textContent = t.unfollow;
                    unfollowBtn.style.cssText = 'padding: 0.5rem 1rem;';
                    unfollowBtn.onclick = async () => {
                        if (confirm(`Unfollow ${username}?`)) {
                            const response = await fetch(`/api/unfollow/${userId}`, { method: 'DELETE', credentials: 'include' });
                            if (response.ok) {
                                window.location.reload();
                            }
                        }
                    };
                    buttonContainer.appendChild(unfollowBtn);
                } else {
                    // PJ601: Block/Unblock button with toggle
                    const blockBtn = document.createElement('button');
                    blockBtn.textContent = isBlocked ? t.unblock : t.block;
                    blockBtn.style.cssText = isBlocked 
                        ? 'padding: 0.5rem 1rem; background-color: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer;'
                        : 'padding: 0.5rem 1rem; background-color: #ef4444; color: white; border: none; border-radius: 6px; cursor: pointer;';
                    blockBtn.onclick = async () => {
                        if (isBlocked) {
                            // Unblock user
                            const response = await fetch(`/api/users/${userId}/unblock`, { method: 'POST', credentials: 'include' });
                            if (response.ok) {
                                window.location.reload();
                            }
                        } else {
                            // Block user
                            if (confirm(`Block ${username}?`)) {
                                const response = await fetch(`/api/users/${userId}/block`, { method: 'POST', credentials: 'include' });
                                if (response.ok) {
                                    window.location.href = '/?view=following';
                                }
                            }
                        }
                    };
                    buttonContainer.appendChild(blockBtn);
                    
                    // Follow button with min-width to match Follow with Note
                    const followBtn = document.createElement('button');
                    followBtn.className = 'btn-primary';
                    followBtn.textContent = t.follow;
                    followBtn.style.cssText = 'padding: 0.5rem 1rem; background-color: #3b82f6; color: white; width: auto;';
                    followBtn.onclick = async () => {
                        const response = await fetch(`/api/follow/${userId}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include',
                            body: JSON.stringify({ note: '' })
                        });
                        if (response.ok) {
                            window.location.reload();
                        }
                    };
                    buttonContainer.appendChild(followBtn);
                }
                
                // PJ702: Add to Circle button - only show if user is not already in any circle
                if (!isInCircles) {
                    const addCircleBtn = document.createElement('button');
                    addCircleBtn.textContent = t.addToCircle;
                    addCircleBtn.style.cssText = 'padding: 0.5rem 1rem; background-color: #22c55e; color: white; border: none; border-radius: 6px; cursor: pointer;';
                    addCircleBtn.onclick = () => {
                        if (typeof showCircleAddMenu === 'function') {
                            showCircleAddMenu(userId, username);
                        }
                    };
                    buttonContainer.appendChild(addCircleBtn);
                }
                
                // Insert at top
                const circlesHeader = container.querySelector('.circles-header');
                if (circlesHeader) {
                    circlesHeader.parentNode.insertBefore(backBtn, circlesHeader);
                    circlesHeader.parentNode.insertBefore(buttonContainer, circlesHeader);
                } else {
                    container.insertBefore(backBtn, container.firstChild);
                    backBtn.after(buttonContainer);
                }
                
                // Update header with username
                const header = container.querySelector('h1');
                if (header) {
                    header.textContent = `${username}'s Circles`;
                }
                
            } catch (error) {
                console.error('Error adding circles action buttons:', error);
            }
        }

        // Language change handler - FIXED to prevent race conditions
        window.addEventListener('languageChanged', async (event) => {
            if (!pageInitialized) return; // Don't handle until page is ready

            // Prevent concurrent language updates
            if (isUpdatingLanguage) {
                console.log('[Circles] Language update already in progress, skipping...');
                return;
            }

            isUpdatingLanguage = true;

            try {
                console.log('Language changed to:', event.detail?.language || window.i18n?.currentLanguage);

                // Update RTL direction
                const rtlLanguages = ['ar', 'he'];
                const newLang = event.detail?.language || window.i18n?.currentLanguage || 'en';
                document.body.setAttribute('dir', rtlLanguages.includes(newLang) ? 'rtl' : 'ltr');

                // Re-apply translations to all data-i18n elements
                if (window.i18n && window.i18n.applyLanguage) {
                    window.i18n.applyLanguage(newLang);
                }

                // Update privacy dropdown
                if (typeof updatePrivacyDropdownTranslations === 'function') {
                    updatePrivacyDropdownTranslations();
                }

                // Force-update circle titles AFTER all other translations (with delay)
                if (typeof updateCircleTitles === 'function') {
                    setTimeout(() => {
                        updateCircleTitles();
                        console.log('[Circles] Circle titles updated after language change');
                    }, 100);
                }
            } finally {
                // Reset flag after a delay to allow for async operations
                setTimeout(() => {
                    isUpdatingLanguage = false;
                }, 300);
            }
        });

        // Start initialization when DOM ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeCirclesPage);
        } else {
            // DOM already loaded
            initializeCirclesPage();
        }
    </script>
</body>
</html>